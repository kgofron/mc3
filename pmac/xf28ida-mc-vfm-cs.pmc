;####################################################
; Generic program for moving any co-ordinate system
;####################################################

;This program defines the program needed to do a move using the motor record
;on a CS axis
;to do a move we need to do &{CS}R
;to stop a move we need to do &{CS}A
;demand values are in &{CS}Q71..79
;The following are set by the motor record:
;Isx87 = Acceleration
;Isx89 = Feedrate

; Set some defaults for all CS axes
i5213,15,100=10 ; segmentation time (needed for lookahead)
i5220,15,100=50 ; lookahead length (needed to limit max velocity to max in CS)
i5250,15,100=1  ; Enable kinematics

OPEN PROG 10
CLEAR
LINEAR
ABS
FRAX(A,B,C,U,V,W,X,Y,Z)
A(Q71)B(Q72)C(Q73)U(Q74)V(Q75)W(Q76)X(Q77)Y(Q78)Z(Q79)
DWELL0
CLOSE

;################################################
; Define motion for XPD mirror vertical movements
; Defined axes:
;   X (addr 6) = pitch
;   Y (addr 7) = roll
;   Z (addr 8) = vertical
;################################################
&1
#1->I ; Upstream outboard vertical
#2->I ; Upstream inboard vertical
#3->I ; Downstream vertical

; Define motor parameters
#define YUI_MTR_MOVE P4701
#define YUI_MTR_MRES P4801
#define YUI_MTR_OFF  P4901
#define YUO_MTR_MOVE P4702
#define YUO_MTR_MRES P4802
#define YUO_MTR_OFF  P4902
#define YD_MTR_MOVE P4703
#define YD_MTR_MRES P4803
#define YD_MTR_OFF  P4903

#define YUI_MTR_POS (YUI_MTR_MRES*P1+YUI_MTR_OFF)
#define YUO_MTR_POS (YUO_MTR_MRES*P2+YUO_MTR_OFF)
#define YD_MTR_POS (YD_MTR_MRES*P3+YD_MTR_OFF)

#define P Q7
#define R Q8
#define Y Q9

#define YU_AVG_POS Q30

OPEN FORWARD CLEAR
YU_AVG_POS=(YUI_MTR_POS+YUO_MTR_POS)/2
P=(YD_MTR_POS-YU_AVG_POS)/1.47
R=(YUO_MTR_POS-YUI_MTR_POS)/0.28
Y=((660*YD_MTR_POS)+(810*YU_AVG_POS))/1470
CLOSE

#define YUI_MTR_POS Q228
#define YUO_MTR_POS Q229
#define YD_MTR_POS Q230
#define YU_AVG_POS Q231

&1   
OPEN INVERSE CLEAR
; Calculate in EGU
YD_MTR_POS = Y + 0.81 * P
YU_AVG_POS = Y - 0.66 * P
YUI_MTR_POS=YU_AVG_POS - 0.14 * R
YUI_MTR_POS=YU_AVG_POS + 0.14 * R

; Calculate in counts
P1 = (YUI_MTR_POS - YUI_MTR_OFF)/YUI_MTR_MRES
P2 = (YUO_MTR_POS - YUO_MTR_OFF)/YUO_MTR_MRES
P3 = (YD_MTR_POS - YD_MTR_OFF)/YD_MTR_MRES
CLOSE

; A PLC(sx+15) needs to be made to do position reporting
; Readbacks should be in &{axisnum}Q81..89
	; As forward kinematic, but with Px = mx62/(Ix08*32)
#define YUI_MTR_POS (YUI_MTR_MRES*M162/(I108*32)+YUI_MTR_OFF)
#define YUO_MTR_POS (YUO_MTR_MRES*M262/(I208*32)+YUO_MTR_OFF)
#define YD_MTR_POS (YD_MTR_MRES*M362/(I308*32)+YD_MTR_OFF)

#define P Q87
#define R Q88
#define Y Q89
#define YU_AVG_POS Q31

	OPEN PLC16
	CLEAR
	ADDRESS&1
  ;; Still to be updated.
  YU_AVG_POS = (YUI_MTR_POS + YUO_MTR_POS) / 2
  P = (YD_MTR_POS - YU_AVG_POS) / 1.470
  R = (YUO_MTR_POS - YUI_MTR_POS)/0.280
  Y = (660 * YD_MTR_POS + 810 * YU_AVG_POS) / 1470

	; If motor record did the last move, set demands = readbacks
	if (YUO_MTR_MOVE = 1)
or (YUI_MTR_MOVE = 1)
or (YD_MTR_MOVE = 1)
	YUO_MTR_MOVE = 0
	YUI_MTR_MOVE = 0
	YD_MTR_MOVE = 0
	Q77 = Q87
	Q78 = Q88
  Q79 = Q89
	endif
	CLOSE
;################################################
; Define motion for benders
; Defined axes:
;   Bend (addr 6) = horizontal movement
;   Offset (addr 7) = vertical movement
;################################################

; Change to CS2
&2

; Set relevant axes to use kinematics
#4->I ; upstream bender motor 
#5->I ; downstream bender motor

; These are set by motor_in_cs.template
#define BEND_U_MTR_MOVE P(4700+4)
#define BEND_U_MTR_MRES P(4800+4)
#define BEND_U_MTR_OFF  P(4900+4)
#define BEND_D_MTR_MOVE P(4700+5)
#define BEND_D_MTR_MRES P(4800+5)
#define BEND_D_MTR_OFF  P(4900+5)

; Calculate vertical and horizontal position from motor positions
#define BEND_U_MTR_POS (BEND_U_MTR_MRES*P1+BEND_U_MTR_OFF)
#define BEND_D_MTR_POS (BEND_D_MTR_MRES*P2+BEND_D_MTR_OFF)
#define BEND Q7
#define OFFSET Q8
OPEN FORWARD
CLEAR
BEND = (BEND_U_MTR_POS + BEND_D_MTR_POS)/2
OFFSET = BEND_U_MTR_POS - BEND_D_MTR_POS
CLOSE

; Calculate motor positions in cts from horizontal and vertical base position
#define BEND_U_MTR_POS Q228
#define BEND_D_MTR_POS Q229
OPEN INVERSE
CLEAR
; calculate in EGUs
BEND_U_MTR_POS = BEND + OFFSET / 2
BEND_D_MTR_POS = BEND - OFFSET / 2
; then in cts
P4 = (BEND_U_MTR_POS - BEND_U_MTR_OFF)/BEND_U_MTR_MRES
P5 = (BEND_D_MTR_POS - BEND_D_MTR_OFF)/BEND_D_MTR_MRES

CLOSE

; A PLC(sx+15) needs to be made to do position reporting
; Readbacks should be in &{axisnum}Q81..89
	; As forward kinematic, but with Px = mx62/(Ix08*32)
#define BEND_U_MTR_POS (BEND_U_MTR_MRES*M162/(I108*32)+BEND_U_MTR_OFF)
#define BEND_D_MTR_POS (BEND_D_MTR_MRES*M262/(I208*32)+BEND_D_MTR_OFF)
#define BEND Q87
#define OFFSET Q88
	OPEN PLC17
	CLEAR
	ADDRESS&2
  BEND = (BEND_U_MTR_POS + BEND_D_MTR_POS) / 2
  OFFSET = BEND_U_MTR_POS - BEND_D_MTR_POS
	; If motor record did the last move, set demands = readbacks
	if (BEND_U_MTR_MOVE = 1)
or (BEND_D_MTR_MOVE = 1)
	BEND_U_MTR_MOVE = 0
	BEND_D_MTR_MOVE = 0
	Q77 = Q87
	Q78 = Q88
	endif
	CLOSE

	;
	;Need to also add the following line to PLC1 so this gets run at startup
	;ENABLE PLC16
	;ENABLE PLC17
	;
	;The following lines should also be added to PLC1 so they are run at startup
	;&16 DEFINE LOOKAHEAD 50,10
	;&15 DEFINE LOOKAHEAD 50,10
	;&14 DEFINE LOOKAHEAD 50,10
	;&13 DEFINE LOOKAHEAD 50,10
	;&12 DEFINE LOOKAHEAD 50,10
	;&11 DEFINE LOOKAHEAD 50,10
	;&10 DEFINE LOOKAHEAD 50,10
	;&9 DEFINE LOOKAHEAD 50,10
	;&8 DEFINE LOOKAHEAD 50,10
	;&7 DEFINE LOOKAHEAD 50,10
	;&6 DEFINE LOOKAHEAD 50,10
	;&5 DEFINE LOOKAHEAD 50,10
	;&4 DEFINE LOOKAHEAD 50,10
	;&3 DEFINE LOOKAHEAD 50,10
	&2 DEFINE LOOKAHEAD 50,10
	&1 DEFINE LOOKAHEAD 50,10
;
